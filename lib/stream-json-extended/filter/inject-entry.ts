import { type Readable, Transform, type TransformOptions } from 'node:stream';
import { isNativeError } from 'node:util/types';

import { chain } from 'stream-chain';
import { omitEntry } from 'multiverse/stream-json-extended';

import { escapeRegExp } from 'multiverse/stream-json-extended/util/escape-regexp';
import { type JsonToken, useStackKeyTracking } from 'multiverse/stream-json-extended';
import { makeSafeCallback } from 'multiverse/stream-json-extended/util/make-safe-callback';

/**
 * Injects a stream of {@link JsonToken}s representing a new entry (key-value
 * pair) at the end of each object.
 *
 * `injectEntry` assumes that a token stream represents subsequent _object_
 * values being streamed one by one, such as a token stream generated by the
 * `pick` or `selectOne` filters.
 */
export function injectEntry({
  entry: { injectionPoint, key, valueTokenStream, autoOmitInjectionKey = true },
  streamKeys = true,
  packKeys = true,
  pathSeparator = '.',
  ...transformOptions
}: TransformOptions & {
  /**
   * The entry to be injected into the token stream.
   */
  entry: {
    /**
     * The point in the object into which this new entry should be injected.
     * `injectionPoint` should be `undefined` (or not provided) if the entry
     * should be injected at the root of the object.
     *
     * If this is a regular expression, you _may_ need to disable automatic
     * ignoring of the injection key by setting `autoOmitInjectionKey` to
     * `false`. This is usually unnecessary unless the regular expression is too
     * complex, uses flags, or contains more than one dollar sign ($) or the
     * dollar sign is not the final character of the expression.
     */
    injectionPoint?: string | RegExp | undefined;
    /**
     * The key of the new entry to inject into the object.
     */
    key: string;
    /**
     * The value of the new entry to inject into the object. This must be a
     * valid stream of {@link JsonToken}s representing a complete json value
     * (i.e. object, array, or valid primitive).
     */
    valueTokenStream: Readable;
    /**
     * If `true`, an {@link omitEntry} filter will be piped into the entry
     * injection stream. The {@link omitEntry} filter will be configured to
     * exclude the `key` entry from the target object by concatenating
     * `injectionPoint + pathSeparator + key` as a regular expression filter
     * without flags.
     *
     * If this is not desired, or you want to do this manually, set
     * `autoOmitInjectionKey` to `false`.
     *
     * @default true
     */
    autoOmitInjectionKey?: boolean;
  };
  /**
   * If `true`, keys will be streamed as unpacked {@link JsonToken}s. If
   * `packKeys` is `false`, `streamKeys` will be forced to `true` regardless of
   * the value provided by this option.
   *
   * @see https://github.com/uhop/stream-json/wiki/Parser#constructoroptions
   */
  streamKeys?: boolean;
  /**
   * If `true`, keys will be streamed as packed {@link JsonToken}s.
   *
   * @see https://github.com/uhop/stream-json/wiki/Parser#constructoroptions
   */
  packKeys?: boolean;
  /**
   * A string that separates stack values when it is converted to a string.
   */
  pathSeparator?: string;
}) {
  const injectionPointIsString = typeof injectionPoint === 'string';
  const { getStack, updateStack } = useStackKeyTracking();

  let waitingForTheEndStack: ReturnType<typeof getStack> | undefined;

  const injectionStream = new Transform({
    ...transformOptions,
    objectMode: true,
    transform(chunk: JsonToken, _encoding, callback) {
      const safeCallback = makeSafeCallback(callback);

      try {
        updateStack(chunk);
        const stack = getStack();

        if (waitingForTheEndStack !== undefined) {
          if (
            chunk.name === 'endObject' &&
            waitingForTheEndStack.toString() === stack.toString()
          ) {
            waitingForTheEndStack = undefined;

            if (streamKeys || !packKeys) {
              const tokens: JsonToken[] = [
                { name: 'startKey' },
                { name: 'stringChunk', value: key },
                { name: 'endKey' }
              ];

              tokens.forEach((token) => this.push(token));
            }

            if (packKeys) {
              this.push({ name: 'keyValue', value: key } satisfies JsonToken);
            }

            let calledCallback = false;

            const onData = (chunk: unknown) => {
              if (!this.push(chunk)) {
                valueTokenStream.pause();
                // ? Handle backpressure during unbounded chunk inflation
                // * https://stackoverflow.com/a/73474849/1367414
                this.once('data', () => valueTokenStream.resume());
              }
            };

            const onEnd = (error?: Error | null) => {
              calledCallback = true;
              valueTokenStream.removeListener('data', onData);
              valueTokenStream.removeListener('end', onEnd);
              valueTokenStream.removeListener('error', onEnd);
              callback(error ?? null);
            };

            valueTokenStream.on('error', (error) => onEnd(error));
            valueTokenStream.on('end', () => onEnd());
            valueTokenStream.on('data', onData);

            if (
              !calledCallback &&
              (valueTokenStream.readableEnded || valueTokenStream.readableAborted)
            ) {
              onEnd();
            }

            return;
          }
        } else {
          const parentStack = stack.slice(0, -1);
          const parentStackPath = parentStack.join(pathSeparator);
          const isEvaluatingAnObjectRoot =
            stack.length >= 1 && typeof stack[0] !== 'number';

          if (isEvaluatingAnObjectRoot) {
            if (injectionPoint === undefined) {
              if (stack.length === 1) {
                waitingForTheEndStack = parentStack;
              }
            } else if (
              injectionPoint === parentStackPath ||
              (!injectionPointIsString && parentStackPath?.match(injectionPoint))
            ) {
              waitingForTheEndStack = parentStack;
            }
          }
        }

        this.push(chunk);
        callback(null);
      } catch (error) {
        safeCallback(isNativeError(error) ? error : new Error(String(error)));
      }
    }
  });

  if (autoOmitInjectionKey) {
    const escapedKey = escapeRegExp(key);
    let filterRegExp: RegExp;

    if (injectionPoint === undefined) {
      filterRegExp = new RegExp(`^${escapedKey}$`);
    } else {
      const regexpSuffix = `${escapeRegExp(pathSeparator)}${escapedKey}$`;

      if (injectionPointIsString) {
        filterRegExp = new RegExp(escapeRegExp(injectionPoint) + regexpSuffix);
      } else {
        const { source } = injectionPoint;
        filterRegExp = new RegExp(
          (source.endsWith('$') ? source.slice(0, -1) : source) + regexpSuffix
        );
      }
    }

    return chain([omitEntry({ key: filterRegExp, pathSeparator }), injectionStream]);
  } else {
    return injectionStream;
  }
}
