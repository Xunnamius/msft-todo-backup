import { type Readable, Transform, type TransformOptions } from 'node:stream';
import { isNativeError } from 'node:util/types';

import { chain } from 'stream-chain';
import { ignore } from 'stream-json/filters/Ignore';

import { escapeRegExp } from 'multiverse/stream-json-extended/util/escape-regexp';
import { type JsonToken, useStackKeyTracking } from 'multiverse/stream-json-extended';
import { makeSafeCallback } from 'multiverse/stream-json-extended/util/make-safe-callback';

/**
 * Injects a stream of {@link JsonToken}s representing a new entry (key-value
 * pair) at the end of each object.
 *
 * `injectEntry` assumes that a token stream represents subsequent _object_
 * values being streamed one by one, such as a token stream generated by the
 * `pick` or `selectOne` filters.
 */
export function injectEntry({
  entry: { injectionPoint, key, valueTokenStream, autoIgnoreInjectionKey = true },
  pathSeparator = '.',
  ...transformOptions
}: TransformOptions & {
  /**
   * The entry to be injected into the token stream.
   */
  entry: {
    /**
     * The object into which this new entry should be injected.
     *
     * If this is a regular expression, you may need to disable automatic
     * ignoring of the injection key by setting `autoIgnoreInjectionKey` to
     * `false`. This is usually unnecessary unless the regular expression is too
     * complex, uses flags, or contains more than one dollar sign ($) or the
     * dollar sign is not the final character of the expression.
     */
    injectionPoint?: string | RegExp;
    /**
     * The key of the new entry to inject into the object.
     */
    key: string;
    /**
     * The value of the new entry to inject into the object. This must be a
     * valid stream of {@link JsonToken}s representing a complete json value
     * (i.e. object, array, or valid primitive).
     */
    valueTokenStream: Readable;
    /**
     * If `true`, an {@link ignore} filter will be piped into the entry
     * injection stream. The {@link ignore} filter will be configured to exclude
     * the `key` from the target object by concatenating `injectionPoint + key`
     * as a regular expression without flags.
     *
     * If this is not desired, or you want to do this manually, set
     * `autoIgnoreInjectionKey` to `false`.
     *
     * @default true
     */
    autoIgnoreInjectionKey?: boolean;
  };
  /**
   * A string that separates stack values when it is converted to a string.
   */
  pathSeparator?: string;
}) {
  const injectionPointIsString = typeof injectionPoint === 'string';
  const { getStack, updateStack } = useStackKeyTracking();

  let waitingForTheEnd = false;

  const injectionStream = new Transform({
    ...transformOptions,
    objectMode: true,
    transform(chunk: JsonToken, _encoding, callback) {
      const safeCallback = makeSafeCallback(callback);

      try {
        updateStack(chunk);
        const stack = getStack();

        if (waitingForTheEnd) {
          if (chunk.name === 'endObject') {
            waitingForTheEnd = false;
            let calledCallback = false;

            const onData = function (this: typeof injectionStream, chunk: unknown) {
              if (!this.push(chunk)) {
                valueTokenStream.pause();
                // ? Handle backpressure during unbounded chunk inflation
                // * https://stackoverflow.com/a/73474849/1367414
                this.once('data', () => valueTokenStream.resume());
              }
            };

            const onEnd = function (error?: Error | null) {
              calledCallback = true;
              valueTokenStream.removeListener('data', onData);
              valueTokenStream.removeListener('end', onEnd);
              valueTokenStream.removeListener('error', onEnd);
              callback(error ?? null);
            };

            valueTokenStream.on('error', (error) => onEnd(error));
            valueTokenStream.on('end', () => onEnd());
            valueTokenStream.on('data', onData);

            if (
              !calledCallback &&
              (valueTokenStream.readableEnded || valueTokenStream.readableAborted)
            ) {
              onEnd();
            }

            return;
          }
        } else {
          const stackPath = stack.slice(0, -1).join(pathSeparator);
          const isEvaluatingAnObjectRoot =
            stack.length >= 1 && typeof stack[0] !== 'number';

          if (isEvaluatingAnObjectRoot) {
            if (injectionPoint === undefined) {
              if (stack.length === 1) {
                waitingForTheEnd = true;
              }
            } else if (
              injectionPoint === stackPath ||
              (!injectionPointIsString && stackPath?.match(injectionPoint))
            ) {
              waitingForTheEnd = true;
            }
          }
        }

        this.push(chunk);
        callback(null);
      } catch (error) {
        safeCallback(isNativeError(error) ? error : new Error(String(error)));
      }
    }
  });

  if (autoIgnoreInjectionKey) {
    const escapedKey = escapeRegExp(key);
    let filterRegExp: RegExp;

    if (injectionPoint === undefined) {
      filterRegExp = new RegExp(`^${escapedKey}$`);
    } else {
      const regexpSuffix = `${escapeRegExp(pathSeparator)}${escapedKey}$`;

      if (injectionPointIsString) {
        filterRegExp = new RegExp(escapeRegExp(injectionPoint) + regexpSuffix);
      } else {
        const { source } = injectionPoint;
        filterRegExp = new RegExp(
          (source.endsWith('$') ? source.slice(0, -1) : source) + regexpSuffix
        );
      }
    }

    return chain([ignore({ filter: filterRegExp, pathSeparator }), injectionStream]);
  } else {
    return injectionStream;
  }
}
